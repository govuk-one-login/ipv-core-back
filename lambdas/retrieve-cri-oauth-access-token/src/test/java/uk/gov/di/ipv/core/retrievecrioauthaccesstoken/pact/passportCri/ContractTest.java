package uk.gov.di.ipv.core.retrievecrioauthaccesstoken.pact.passportCri;

import au.com.dius.pact.consumer.MockServer;
import au.com.dius.pact.consumer.dsl.PactDslWithProvider;
import au.com.dius.pact.consumer.junit.MockServerConfig;
import au.com.dius.pact.consumer.junit5.PactConsumerTestExt;
import au.com.dius.pact.consumer.junit5.PactTestFor;
import au.com.dius.pact.core.model.RequestResponsePact;
import au.com.dius.pact.core.model.annotations.Pact;
import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.JWSSigner;
import com.nimbusds.jose.util.Base64URL;
import com.nimbusds.oauth2.sdk.token.AccessTokenType;
import com.nimbusds.oauth2.sdk.token.BearerAccessToken;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import uk.gov.di.ipv.core.library.config.ConfigurationVariable;
import uk.gov.di.ipv.core.library.dto.CredentialIssuerConfig;
import uk.gov.di.ipv.core.library.helpers.SecureTokenHelper;
import uk.gov.di.ipv.core.library.service.ConfigService;
import uk.gov.di.ipv.core.retrievecrioauthaccesstoken.service.AuthCodeToAccessTokenService;

import java.net.URI;
import java.net.URISyntaxException;
import java.time.Clock;
import java.time.Instant;
import java.time.ZoneOffset;
import java.util.Set;

import static au.com.dius.pact.consumer.dsl.LambdaDsl.newJsonBody;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.notNullValue;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.greaterThan;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

//@Disabled("PACT tests should not be run in build pipelines at this time")
@ExtendWith(PactConsumerTestExt.class)
@ExtendWith(MockitoExtension.class)
@PactTestFor(providerName = "PassportCriProvider")
@MockServerConfig(hostInterface = "localhost", port = "1234")
class ContractTest {

    public static final String IPV_CORE_CLIENT_ID = "ipv-core";
    public static final String CRI_SIGNING_PRIVATE_KEY_JWK =
            "{\"kty\":\"EC\",\"d\":\"OXt0P05ZsQcK7eYusgIPsqZdaBCIJiW4imwUtnaAthU\",\"crv\":\"P-256\",\"x\":\"E9ZzuOoqcVU4pVB9rpmTzezjyOPRlOmPGJHKi8RSlIM\",\"y\":\"KlTMZthHZUkYz5AleTQ8jff0TJiS3q2OB9L5Fw4xA04\"}";
    public static final String CRI_RSA_ENCRYPTION_PUBLIC_JWK =
            "{\"kty\":\"RSA\",\"e\":\"AQAB\",\"n\":\"vyapkvJXLwpYRJjbkQD99V2gcPEUKrO3dwjcAA9TPkLucQEZvYZvb7-wfSHxlvJlJcdS20r5PKKmqdPeW3Y4ir3WsVVeiht2iOZUreUO5O3V3o7ImvEjPS_2_ZKMHCwUf51a6WGOaDjO87OX_bluV2dp01n-E3kiIl6RmWCVywjn13fX3jsX0LMCM_bt3HofJqiYhhNymEwh39oR_D7EE5sLUii2XvpTYPa6L_uPwdKa4vRl4h4owrWEJaJifMorGcvqhCK1JOHqgknN_3cb_ns9Px6ynQCeFXvBDJy4q71clkBq_EZs5227Y1S222wXIwUYN8w5YORQe3M-pCIh1Q\"}";
    public static final String CRI_RSA_ENCRYPTION_PRIVATE_KEY =
            "MIIEuwIBADANBgkqhkiG9w0BAQEFAASCBKUwggShAgEAAoIBAQC/JqmS8lcvClhEmNuRAP31XaBw8RQqs7d3CNwAD1M+Qu5xARm9hm9vv7B9IfGW8mUlx1LbSvk8oqap095bdjiKvdaxVV6KG3aI5lSt5Q7k7dXejsia8SM9L/b9kowcLBR/nVrpYY5oOM7zs5f9uW5XZ2nTWf4TeSIiXpGZYJXLCOfXd9feOxfQswIz9u3ceh8mqJiGE3KYTCHf2hH8PsQTmwtSKLZe+lNg9rov+4/B0pri9GXiHijCtYQlomJ8yisZy+qEIrUk4eqCSc3/dxv+ez0/HrKdAJ4Ve8EMnLirvVyWQGr8RmznbbtjVLbbbBcjBRg3zDlg5FB7cz6kIiHVAgMBAAECggEAdHFl7YlJSPOhT7BaWNvk2Lq/SO3jHhw6j/3KnxK23/+/5wEHoCer7MQ2DBRIam6g5UGmHMZwS9q9ckkJdGfxC7uXdJGPtMwECmNdhE08JIMpvJj4ZUKt99EnQdMrHOJRXmgKAI+YQ68Piu+FkF+McxwhIEn69/vbqlo3kdp/hZ2IhmMN6GTYFznj5E0N5/8kTFVZWCVtie5V2N0DosNeKqDcnKdB8rbY0vmHFAlKmhrXS+DKOI6O0+t9o1MUreThr1oMpegQbu1vayRpm8YAR6tfJ3UTVIhaywIcnsgmJf8EOcAlm9QlVYMB0bzVn4PyroNrXj/C6NRBqK7zrSh0ZQKBgQD7IlX8R7+b++ltpcBhzmcudCIsJyg6npCsXufanr4IaeFB/mrGfkEDC3ntOSXXbuoDnGDXZUhEsEYxp48nFBD3igrimn3epP6rqbbQA4YkLxzr41QjkBLhoBY3eQAX2Mdltah3ibCADsSYLu47ALOwXC92Qd+N45tEcHAyGxXbYwKBgQDC2s0SZc0q3lXk+lhDCYvrhqXOscl49lqQQTVWZWCQEmg1AZ0M+Ice9cSoMth5JZviRrkrt1FH+swCU5hb1H36zexkJEYX5Ie+27rqvvS7UW6ms5gQHUAGEESmoA2iJoaA6taNaHs6w9GB7E1Z/RFNCn81NZxuY4hFBgNFZji/ZwKBgCR57UFSbotKgLIzZAkQwL3nklsVaOtywpK2yjhf3Dw+nMBIItwn1GuLzC7foRZ0frr9iLdgd6m6bMejjdBgQsKho0kcpXGkR3VJlksKZ/5zdWDxyPPNZmCtLuzpv1C3ZObqBskuD5vaCUYNcv7Q8EiKaz5i/QSP7ap4JmOwuXD/An8hfXnBr72ToKMit+RzoTBrSrk0zVnTcIQgRxTjxIjUOlWuxpg3on+W0qb6QcLzD4O7YGxzFw7hUDnALJ4DKoJ8mOgITjO954ltRFbcAfYOO/DIthVsr5pRcHpcKSYuuHBlt/coVszXTNC1g+fHj7dphmRWwOAiGPlS47WsN+WJAoGBAPKQ30uMQ1kHUCiIabRKO0jLpHHE/yRbo+IdWek3gc9wQHq7xRgks8zUfWv4UWZVjmYaG1Rm3DVGy6AbWuPZThBByR3v7uM50F4ezY+UGCpxV0wwo8Si46/aSWQM0C7TxTMn1QhYu9W9kKL1DJKr721c0Rh3cuDPg/MJdSCRlMM0";
    // This public/private key pair was generated by https://mkjwk.org/
    // Used with https://jwt.io to generate the signature for request JWT as mocking out the AWSKMS
    // class inside the signer would be painful.
    public static final String CORE_BACK_SIGNING_PRIVATE_KEY_JWK =
            "{\"kty\":\"EC\",\"d\":\"1xHsNblCTGo6QN3KdsDVfW6_00H5TTZDZzo1PxD76oc\",\"crv\":\"P-256\",\"x\":\"JbDnBuuRUDrZtij2hqZXrVGLqfgAvsilejUSM0EDQi8\",\"y\":\"1HGVr6fiUocpzK8y8rq8OlskRWoVDr-4lPUskPnew9c\"}";

    @Mock private ConfigService mockConfigServce;
    @Mock private JWSSigner mockSigner;
    @Mock private SecureTokenHelper mockSecureTokenHelper;

    @Pact(provider = "PassportCriProvider", consumer = "IpvCoreBack")
    public RequestResponsePact validRequestReturnsValidAccessToken(PactDslWithProvider builder) {
        return builder.given("dummyAuthCode is a valid authorization code")
                .given("dummyApiKey is a valid api key")
                .given("dummyPassportComponentId is the passport CRI component ID")
                .given(
                        "Passport CRI uses CORE_BACK_SIGNING_PRIVATE_KEY_JWK to validate core signatures")
                .uponReceiving("Valid auth code")
                .path("/token")
                .method("POST")
                .body(
                        "client_assertion_type=urn%3Aietf%3Aparams%3Aoauth%3Aclient-assertion-type%3Ajwt-bearer&code=dummyAuthCode&grant_type=authorization_code&redirect_uri=https%3A%2F%2Fidentity.staging.account.gov.uk%2Fcredential-issuer%2Fcallback%3Fid%3DukPassport&client_assertion=eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NiJ9.eyJpc3MiOiJpcHYtY29yZSIsInN1YiI6Imlwdi1jb3JlIiwiYXVkIjoiZHVtbXlQYXNzcG9ydENvbXBvbmVudElkIiwiZXhwIjo0MDcwOTA5NzAwLCJqdGkiOiJTY25GNGRHWHRoWllYU181azg1T2JFb1NVMDRXLUgzcWFfcDZucHYyWlVZIn0.hXYrKJ_W9YItUbZxu3T63gQgScVoSMqHZ43UPfdB8im8L4d0mZPLC6BlwMJSsfjiAyU1y3c37vm-rV8kZo2uyw")
                .headers(
                        "x-api-key",
                        "dummyApiKey",
                        "Content-Type",
                        "application/x-www-form-urlencoded; charset=UTF-8")
                .willRespondWith()
                .status(200)
                .body(
                        newJsonBody(
                                        (body) -> {
                                            body.stringType("access_token");
                                            body.stringValue("token_type", "Bearer");
                                            body.integerType("expires_in");
                                        })
                                .build())
                .toPact();
    }

    @Test
    @PactTestFor(pactMethod = "validRequestReturnsValidAccessToken")
    void testCallToDummyPassportCri(MockServer mockServer)
            throws URISyntaxException, JOSEException {
        // Arrange
        var credentialIssuerConfig =
                new CredentialIssuerConfig(
                        new URI("http://localhost:" + mockServer.getPort() + "/token"),
                        new URI("http://localhost:" + mockServer.getPort() + "/credential"),
                        new URI("http://localhost:" + mockServer.getPort() + "/authorize"),
                        IPV_CORE_CLIENT_ID,
                        CRI_SIGNING_PRIVATE_KEY_JWK,
                        CRI_RSA_ENCRYPTION_PUBLIC_JWK,
                        "dummyPassportComponentId",
                        URI.create(
                                "https://identity.staging.account.gov.uk/credential-issuer/callback?id=ukPassport"),
                        true);

        when(mockConfigServce.getSsmParameter(ConfigurationVariable.JWT_TTL_SECONDS))
                .thenReturn("900");
        // Signature generated by jwt.io by debugging the test and getting the client assertion JWT
        // generated by the test as mocking out the AWSKMS class inside the real signer would be
        // painful.
        when(mockSigner.sign(any(), any()))
                .thenReturn(
                        new Base64URL(
                                "hXYrKJ_W9YItUbZxu3T63gQgScVoSMqHZ43UPfdB8im8L4d0mZPLC6BlwMJSsfjiAyU1y3c37vm-rV8kZo2uyw"));
        when(mockSigner.supportedJWSAlgorithms()).thenReturn(Set.of(JWSAlgorithm.ES256));
        when(mockSecureTokenHelper.generate())
                .thenReturn("ScnF4dGXthZYXS_5k85ObEoSU04W-H3qa_p6npv2ZUY");

        // We need to generate a fixed request, so we set the secure token and expiry to constant
        // values.
        var underTest =
                new AuthCodeToAccessTokenService(
                        mockConfigServce,
                        mockSigner,
                        mockSecureTokenHelper,
                        Clock.fixed(Instant.parse("2099-01-01T00:00:00.00Z"), ZoneOffset.UTC));

        // Act
        BearerAccessToken accessToken =
                underTest.exchangeCodeForToken(
                        "dummyAuthCode",
                        credentialIssuerConfig,
                        "dummyApiKey",
                        "dummyCredentialIssuerId");

        // Assert
        assertThat(accessToken.getType(), is(AccessTokenType.BEARER));
        assertThat(accessToken.getValue(), notNullValue());
        assertThat(accessToken.getLifetime(), greaterThan(0L));
    }
}
