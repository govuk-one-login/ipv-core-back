import config from "../config/config.js";
import { encryptJarRequest, generateJarPayload } from "./jar-generator.js";
import path from "path";
import { fileURLToPath } from "url";
import fs from "node:fs/promises";
import { createSignedJwt } from "./jwt-signer.js";
import {
  CriStubGenerateDcmawAsyncVcScenarioRequest,
  CriStubGenerateVcRequest,
  CriStubRequest,
  CriStubResponse,
} from "../types/cri-stub.js";
import { IpvSessionDetails } from "./ipv-session.js";
import {
  AuthRequestBody,
  ProcessCriCallbackRequest,
} from "../types/internal-api.js";
import { EvcsStubPostVcsRequest } from "../types/evcs-stub.js";

const ORCHESTRATOR_CLIENT_ID = "orchApiTest";
const __dirname = path.dirname(fileURLToPath(import.meta.url));
type JsonType = "credentialSubject" | "evidence";

export const generateInitialiseIpvSessionBody = async (
  session: IpvSessionDetails,
): Promise<AuthRequestBody> => {
  const jarPayload = await generateJarPayload(session);

  return {
    responseType: "code",
    clientId: jarPayload.client_id,
    redirectUri: jarPayload.redirect_uri,
    state: "api-tests-state",
    scope: jarPayload.scope,
    request: await encryptJarRequest(jarPayload),
  };
};

export const generateProcessCriCallbackBody = (
  criStubResponse: CriStubResponse,
): ProcessCriCallbackRequest => {
  const url = new URL(criStubResponse.redirectUri);
  const params = url.searchParams;
  const criId = params.get("id") || url.pathname.split("/")[3];

  // Success params
  const code = params.get("code");
  const state = params.get("state");

  // Error params
  const error = params.get("error");
  const errorDescription = params.get("errorDescription");

  return {
    authorizationCode: code ?? undefined,
    state: state ?? undefined,
    error: error ?? undefined,
    errorDescription: errorDescription ?? undefined,
    redirectUri: `${url.protocol}//${url.host}${url.pathname}`,
    credentialIssuerId: criId,
  };
};

export const generateCriStubBody = async (
  criId: string,
  scenario: string | undefined,
  redirectUrl: string,
  nbf?: number,
  f2f?: {
    sendVcToQueue: boolean;
    sendErrorToQueue: boolean;
  },
  mitigatedCis?: string[],
): Promise<CriStubRequest> => {
  const urlParams = new URL(redirectUrl).searchParams;
  const f2fRequest = f2f
    ? {
        sendVcToQueue: f2f.sendVcToQueue,
        sendErrorToQueue: f2f.sendErrorToQueue,
        queueName: config.asyncQueue.name,
        delaySeconds: config.asyncQueue.delaySeconds,
      }
    : undefined;
  const mitigations = mitigatedCis
    ? {
        mitigatedCi: mitigatedCis,
        cimitStubUrl: config.cimit.managementCimitUrl,
        cimitStubApiKey: config.cimit.managementCimitApiKey,
      }
    : undefined;

  return {
    clientId: urlParams.get("client_id") as string,
    request: urlParams.get("request") as string,
    credentialSubjectJson: scenario
      ? await readJsonFile(criId, scenario, "credentialSubject")
      : undefined,
    evidenceJson: scenario
      ? await readJsonFile(criId, scenario, "evidence")
      : undefined,
    nbf,
    f2f: f2fRequest,
    mitigations,
  };
};

export const generateCriStubOAuthErrorBody = (
  error: string,
  redirectUrl: string,
  errorDescription?: string,
): CriStubRequest => {
  const urlParams = new URL(redirectUrl).searchParams;
  return {
    clientId: urlParams.get("client_id") as string,
    request: urlParams.get("request") as string,
    requestedError: {
      error,
      description: errorDescription || "Error generated by API tests",
      endpoint: "auth",
    },
  };
};

export const generateCriStubUserInfoEndpointErrorBody = (
  redirectUrl: string,
): CriStubRequest => {
  const urlParams = new URL(redirectUrl).searchParams;
  return {
    clientId: urlParams.get("client_id") as string,
    request: urlParams.get("request") as string,
    requestedError: {
      apiError: "404",
      endpoint: "credential",
    },
  };
};

export const generateTokenExchangeBody = async (
  redirectUrl: string,
): Promise<string> => {
  const code = new URL(redirectUrl).searchParams.get("code");
  if (!code) {
    throw new Error("code not received in redirect URL");
  }

  const params = new URLSearchParams();
  params.set("grant_type", "authorization_code");
  params.set("code", code);
  params.set("redirect_uri", config.orch.redirectUrl);
  params.set("client_id", ORCHESTRATOR_CLIENT_ID);
  params.set(
    "client_assertion_type",
    "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
  );
  params.set(
    "client_assertion",
    await createSignedJwt({
      sub: ORCHESTRATOR_CLIENT_ID,
      iss: ORCHESTRATOR_CLIENT_ID,
    }),
  );

  return params.toString();
};

export const generateVcRequestBody = async (
  userId: string,
  criId: string,
  scenario: string,
  nbf?: number,
): Promise<CriStubGenerateVcRequest> => {
  return {
    userId: userId,
    clientId: config.core.criClientId,
    credentialSubjectJson: await readJsonFile(
      criId,
      scenario,
      "credentialSubject",
    ),
    evidenceJson: await readJsonFile(criId, scenario, "evidence"),
    nbf: nbf ?? Math.floor(Date.now() / 1000),
  };
};

export const generatePostVcsBody = (
  credentialsToPost: string[],
): EvcsStubPostVcsRequest => {
  return credentialsToPost.map((cred) => ({
    vc: cred,
    state: "CURRENT",
    metadata: {},
    provenance: "ONLINE",
  }));
};

export const generateDcmawAsyncVcCreationBodyFromScenario = async (
  userId: string,
  criId: string,
  scenario: string,
  mitigatedCis: string[] = [],
  nbf?: number,
): Promise<CriStubGenerateDcmawAsyncVcScenarioRequest> => {
  return {
    user_id: userId,
    credential_subject: JSON.parse(
      await readJsonFile(criId, scenario, "credentialSubject"),
    ),
    evidence: JSON.parse(await readJsonFile(criId, scenario, "evidence")),
    queue_name: config.asyncQueue.name,
    nbf: nbf,
    mitigated_cis: {
      mitigatedCis: mitigatedCis,
      cimitStubUrl: config.cimit.managementCimitUrl,
      cimitStubApiKey: config.cimit.managementCimitApiKey,
    },
  };
};

const readJsonFile = async (
  criId: string,
  scenario: string,
  jsonType: JsonType,
) => {
  return await fs.readFile(
    path.join(
      __dirname,
      `../../data/cri-stub-requests/${criId}/${scenario}/${jsonType}.json`,
    ),
    "utf8",
  );
};
